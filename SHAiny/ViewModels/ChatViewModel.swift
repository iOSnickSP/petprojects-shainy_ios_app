//
//  ChatViewModel.swift
//  SHAiny
//
//  Created by –°–µ—Ä–≥–µ–π –í–∏—Ö–ª—è–µ–≤ on 26.10.2025.
//

import Foundation
import Combine

final class ChatViewModel: ObservableObject {
    let chat: Chat
    
    @Driver var messages: [Message] = []
    @Driver var messageText: String = ""
    @Driver var participantsCount: Int = 0
    @Driver var isLoading: Bool = false
    @Driver var hasMoreMessages: Bool = false
    @Driver var chatName: String = ""
    @Published var shouldShowNicknameDialog: Bool = false
    
    private var cancellables = Set<AnyCancellable>()
    private let chatService = ChatService.shared
    private let webSocketService = WebSocketService.shared
    private var currentOffset = 0
    private let pageSize = 50
    private var pendingMessageText: String?
    
    var canSendMessages: Bool {
        return !chat.isReadOnly
    }
    
    init(chat: Chat) {
        self.chat = chat
        self.participantsCount = chat.participantsCount
        self.chatName = chat.name
        setupBindings()
        loadMessages()
        setupWebSocketListener()
    }
    
    private func setupBindings() {
        $messages
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
        
        $messageText
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
        
        $participantsCount
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
        
        $isLoading
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
        
        $hasMoreMessages
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
        
        $chatName
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    private func setupWebSocketListener() {
        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ WebSocket
        webSocketService.newMessagePublisher
            .filter { [weak self] (chatId, _) in
                chatId == self?.chat.chatId
            }
            .sink { [weak self] (_, incomingMessage) in
                guard let self = self else { return }
                
                // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                var decryptedText = incomingMessage.text
                
                if let encryptionKey = self.chat.encryptionKey {
                    do {
                        decryptedText = try CryptoUtils.decrypt(incomingMessage.text, keyPhrase: encryptionKey)
                    } catch {
                        print("‚ùå Failed to decrypt message: \(error.localizedDescription)")
                    }
                }
                
                // –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ (isFromCurrentUser —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ WebSocketService)
                let message = Message(
                    id: incomingMessage.id,
                    text: decryptedText,
                    encryptedText: incomingMessage.encryptedText,
                    shaHash: incomingMessage.shaHash,
                    timestamp: incomingMessage.timestamp,
                    isFromCurrentUser: incomingMessage.isFromCurrentUser,
                    senderName: incomingMessage.senderName
                )
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ —ç—Ç–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–ø–∏—Å–∫–µ
                if !self.messages.contains(where: { $0.id == message.id }) {
                    self.messages.append(message)
                    print("üì© New message added to chat \(self.chat.name)")
                }
            }
            .store(in: &cancellables)
    }
    
    private func loadMessages(reset: Bool = true) {
        if reset {
            currentOffset = 0
        }
        
        isLoading = true
        
        Task {
            do {
                let result = try await chatService.fetchMessages(
                    chatId: chat.chatId,
                    encryptionKey: chat.encryptionKey,
                    limit: pageSize,
                    offset: currentOffset
                )
                
                await MainActor.run {
                    if reset {
                        self.messages = result.messages
                    } else {
                        self.messages.insert(contentsOf: result.messages, at: 0)
                    }
                    self.hasMoreMessages = result.hasMore
                    self.currentOffset += result.messages.count
                    self.isLoading = false
                }
            } catch {
                await MainActor.run {
                    self.isLoading = false
                    print("‚ùå Failed to load messages: \(error.localizedDescription)")
                }
            }
        }
    }
    
    func loadMoreMessages() {
        guard !isLoading && hasMoreMessages else { return }
        loadMessages(reset: false)
    }
    
    func sendMessage() {
        guard !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            return
        }
        
        let textToSend = messageText
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –Ω–∏–∫–Ω–µ–π–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —ç—Ç–æ–º —á–∞—Ç–µ
        Task {
            do {
                let nickname = try await chatService.getNickname(for: chat.chatId)
                
                if nickname == nil {
                    // –ï—Å–ª–∏ –Ω–∏–∫–Ω–µ–π–º–∞ –Ω–µ—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥
                    await MainActor.run {
                        self.pendingMessageText = textToSend
                        // –ù–ï –æ—á–∏—â–∞–µ–º messageText - –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞
                        self.shouldShowNicknameDialog = true
                    }
                    return
                }
                
                // –ï—Å–ª–∏ –Ω–∏–∫–Ω–µ–π–º –µ—Å—Ç—å, –æ—á–∏—â–∞–µ–º –ø–æ–ª–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                await MainActor.run {
                    self.messageText = ""
                }
                
                await sendMessageInternal(textToSend)
            } catch {
                await MainActor.run {
                    print("‚ùå Failed to check nickname: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func sendMessageInternal(_ textToSend: String) async {
        do {
            // –®–∏—Ñ—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            var encryptedText = textToSend
            if let encryptionKey = chat.encryptionKey {
                encryptedText = try CryptoUtils.encrypt(textToSend, keyPhrase: encryptionKey)
            }
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º SHA hash –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
            let shaHash = CryptoUtils.generateHash(textToSend)
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —á–µ—Ä–µ–∑ WebSocket
            webSocketService.sendChatMessage(
                chatId: chat.chatId,
                encryptedText: encryptedText,
                shaHash: shaHash
            )
            
            print("üì§ Message sent to chat: \(chat.name)")
        } catch {
            await MainActor.run {
                print("‚ùå Failed to send message: \(error.localizedDescription)")
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—Å—Ç –æ–±—Ä–∞—Ç–Ω–æ –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
                self.messageText = textToSend
            }
        }
    }
    
    func updateParticipantsCount(_ count: Int) {
        participantsCount = count
    }
    
    func renameChat(newName: String) async -> Bool {
        guard let encryptionKey = chat.encryptionKey else {
            print("‚ùå No encryption key for chat")
            return false
        }
        
        do {
            try await chatService.renameChat(chatId: chat.chatId, newName: newName, encryptionKey: encryptionKey)
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ
            await MainActor.run {
                self.chatName = newName
            }
            
            print("‚úÖ Chat renamed to: \(newName)")
            return true
        } catch {
            print("‚ùå Failed to rename chat: \(error.localizedDescription)")
            return false
        }
    }
    
    // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∏–∫–Ω–µ–π–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —ç—Ç–æ–º —á–∞—Ç–µ
    func setNickname(_ nickname: String) async -> Bool {
        guard !nickname.isEmpty else { return false }
        
        do {
            try await chatService.setNickname(nickname, for: chat.chatId)
            print("‚úÖ Nickname set to: \(nickname)")
            
            // –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–∏–∫–Ω–µ–π–º–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            if let pendingText = pendingMessageText {
                await MainActor.run {
                    self.pendingMessageText = nil
                    self.messageText = "" // –¢–µ–ø–µ—Ä—å –æ—á–∏—â–∞–µ–º –ø–æ–ª–µ
                }
                await sendMessageInternal(pendingText)
            }
            
            return true
        } catch {
            print("‚ùå Failed to set nickname: \(error.localizedDescription)")
            return false
        }
    }
    
    // –û—Ç–º–µ–Ω–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —Å–æ–æ–±—â–µ–Ω–∏—è
    func cancelPendingMessage() {
        pendingMessageText = nil
        // messageText –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å - –Ω–µ –æ—á–∏—â–∞–µ–º
    }
}

